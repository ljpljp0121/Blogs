## ECS架构存储状态机
为什么在ECS中存储状态机还是很好的，以及我想出了哪些解决方案来解决这些问题。
## 状态机
首先使用状态机时的一些功能和操作：
1. 将一个实体的状态替换为另一个状态
2. 让实体参与多个状态机
3. 获取一个状态的当前实体
4. 获取实体/状态机的当前状态
5. 获取状态机的当前实体
6. 更改属于状态机的状态列表
7. 获取状态机中所有状态的列表

一个状态机的实现不仅要能够为这些提供高效的实现，还应该让代码具有可读性，同时尽量减少状态机变化时的重构量

在进入细节之前，特别强调一下可读、可维护的代码的重要性。只关注某一特定解决方案的性能是很有诱惑力的。状态机引入了许多设计挑战，如果不加以解决，就会成为技术债务的来源。
## A tag per state
ECS中的标签是一个没有数据的组件，我们可以为每个状态创建一个单一的标签。在查询给定状态的所有实体时，这种方法的表现一般都很好，因为找到给定组件/标签的所有实体是ECS实现通常所擅长的。

那其他的操作呢？首先，要改变状态，我们必须增加一个标签，并删除另一个标签。在伪代码中，这就是将实体的状态从 "行走 "改为 "奔跑 "的样子。
```csharp
e.add<Running>()
e.remove<Walking>()
```
第一个问题是，为了移除Walking，应用程序首先必须知道实体实际上处于Walking状态，这只是特定状态机潜在的许多状态之一。那么如何解决这个问题呢？在不增加更多复杂性的情况下，其实并没有一个好的方法。一种方法是将当前状态存储在另一个组件中。
```csharp
Movement& m = e.get<Movement>();
if (m == MovementStateWalking) {
  e.remove<Walking>(); 
} else if ( /* test other states ... */) {
}
m = MovementStateRunning;
e.add<Running>()
```
另一种方法是写一个测试状态的实用函数，用它来代替状态机组件：
```csharp
MovementState get_movement(entity e) {
  if (e.has<Walking>()) return MovementStateWalking;
  if (e.has<Running>()) return MovementStateRunning;
  /* test other states ... */
}
```
这两种方法都不是特别吸引人，而且给使用状态机的代码部分增加了可维护性和性能问题。每次状态机发生变化时，相应的实用程序也必须更新。

当一个应用程序需要获取特定状态机的当前状态时，也会出现同样的问题。这将再次依赖于一个组件来存储当前状态，或者依赖于一个状态机的特定函数。

如果不创建额外的实用程序，也无法获得特定状态机的实体列表。例如，一个应用程序可以为状态机中的所有状态创建一个查询，每当状态机发生变化时，这个查询就必须更新。
```csharp
MovementState get_movement(entity e) {
query<Sitting, Standing, Walking, Running, ...>();
}
```
根据使用何种ECS，这样的查询可能会随着更多的状态被添加到查询中而最终变慢。另一种方法将再次依赖于每个状态机的组件。

我们也来看看存储方面的影响。有许多不同的方法来实现ECS，其中两种流行的方法是 原型(archetypes) 和 稀疏集(sparse sets)。基于标签的方法会给这两种存储实现带来很大的压力。我们来看看为什么。
## Archetypes
一个原型实现将具有相同组件集的实体一起存储在一个表中。在不深入了解细节的情况下，这提供了高缓存效率的组件迭代，因为多个组件总是可以作为连续的数组进行迭代。然而，这也是有代价的。

为了使具有相同组件集的实体保持在一起，当添加或删除组件时，实体需要在表之间移动。这也适用于标记。因此，频繁地添加/删除与状态相关联的标签会变得非常昂贵，因为一个实体的所有组件需要为每个状态转换复制（事实上，由于存储的特殊性，这需要为每个组件复制两份）。

另一个挑战是，当一个实体参与多个正交状态机时，每一个状态的组合都会引起组合表的爆炸，这就增加了碎片化，根据ECS的实现，也会拖慢代码的其他部分。

这对状态机来说，简直是个大难题。

## Sparse Sets 稀疏集