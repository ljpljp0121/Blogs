# 设计模式
**定义**：每一种模式都在说明某种一再出现的问题，并描述解决问题的核心，之后让你能够据以变化出各种招式，来解决上万个类似的问题。
### 面向对象设计常见的设计原则
#### 单一职责原则
当设计封装一个类时，该类应该只负责一件事。
#### 开——闭原则
一个类应该对拓展开放，对修改关闭。
实现系统的某项功能，除非是修改功能错误，否则，当软件的开发流程进入完工测试期和上市维护期，对于已经测试完成或已经上线运行的功能，就应该关闭对修改的需求。
重新实现一个新的子类，或者继承旧的实现类，并在新的子类中实现新增的系统功能。
#### 里氏替换原则
子类必须能够替换父类
如果按这个设计原则去设计多层继承的类群组。那么其中的父类通常是"接口类"或者"可被继承的类"
#### 依赖倒置原则
高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念
抽象接口不应该依赖实现，而实现应该依赖抽象接口
#### 接口隔离原则
客户端不应该被迫使用他们用不到的接口方法。

## 常用设计模式

### 状态模式(State)
让一个对象的行为随着内部状态的改变而变化，而该对象也像换了类一样。
#### 参与者说明:
一般是使用一个Context(状态拥有者)和State(状态接口类)和ConcreteState(具体状态类)
#### 优点
1. 减少错误的发生并降低维护难度
2. 状态执行环境单一化
3. 项目之间可以共享场景
   
### 外观模式(Facade)
为子系统定义一组统一的接口，这个高级接口会让子系统更容易被使用。
#### 参与者说明:
1. **client(客户端、用户)**
从原本需要操作多个子系统的情况，改为只需要面对一个整合后的界面
2. **subSystem(子系统)**
   原本会由不同的客户端来操作，改为只会由内部系统之间交互使用
3. **Facade(统一对外的接口)**
   整合所有子系统的接口及功能，并提供高级界面供客户端使用
   接收客户端的信息后，将信息传送给负责的子系统

#### 优点
1. 节省时间
   减少系统之间的耦合度，有助于减少系统构建的时间。
2. 易于分工开发
   在工作分工配合上，只需要了解对方负责系统的Facade接口类，不必深入了解其中的运行方式。
3. 增加系统的安全性
   隔离了客户端对子系统的接触。

### 单例模式(Singleton)
确认类只有一个对象，并提供一个全局的方法来获取这个对象
#### 参与者说明:
1. 能够产生唯一对象的类，并且提供“全局方法”让外界可以方便获取唯一的对象
2. 通常会把唯一的类对象设置为“静态类属性”
3. 习惯上会使用Instance作为全局静态方法的名称，通过这个静态函数可能获取“静态类属性”
#### 优点
1. 可以限制对象的产生数量，提供方便获取唯一对象的方法
#### 缺点
1. 容易造成设计思考不周和过度使用的问题，应当在仔细设计和特定的前提之下，适当地采用单例模式。

### 中介者模式(Mediator)
定义一个接口用来封装一群对象的互动行为。中介者通过移除对象之间的引用，来减少他们之间的耦合度，并且能改变他们之间的互动独立性。
#### 参与者说明:
1. Colleague(同事接口)
   拥有一个Mediator的属性成员，可以通过它来调用中介者的功能
2. ConcreteColleagueX(同事接口的实现类)
   实现Colleague界面的类，对于单一实现类而言，只会依赖一个Mediator接口
3. Mediator(中介者接口)、ConcreteMediator(中介者接口实现类)
   由Mediator定义让Colleague类操作的接口
   ConcreteMediator实现类中包换所有ConcreteColleague的对象引用
   ConcreteMediator类之间的互动会在ConcreteMediator中发生
#### 优点
1. 不会引入太多其他的系统
2. 系统被依赖的程度也降低

### 桥接模式(Bridge)
将抽象和实现分离，使二者可以独立地变化
#### 参与者说明:
1. Abstraction(抽象体接口)
   拥有指向Implementor的的对象引用
   定义抽象功能的接口，也可以作为子类调用实现功能的接口
2. RefinedAbstraction(抽象类实现、扩充)
   继承抽象体并调用Implementor完成实现功能
   扩展抽象体的接口，增加额外的功能
3. Implementor(实现体接口)
   定义实现功能的接口，并提供给Abstraction使用
   接口功能可以只有单一的功能，真正的选择则再由Abstraction的需求加以组合应用
4. ConcreteImplementorA/B(实现体)
   实际完成实现体接口上述所定义的方法。
#### 优点
运用桥接模式后的ICharacter(角色接口)就是群组一“抽象类”，它定义了“攻击目标”功能，但真正实现“攻击目标”功能的类，则是群组二“IWeapon”(武器接口)“实现类”。对于ICharacter及其继承类都不必理会IWeapon群组的变化，尤其是游戏开发后期可能增加的武器类型。而对于ICharacter来说，它面对的只有IWeapon这个接口类，相对地，IWeapon类群组也不必理会角色类群组内的新增或修改，让两个群组之间的耦合度降到最低。

### 策略模式(Strategy)
定义一组算法，并封装每个算法，让它们可以彼此交换使用。策略模式让这些算法在客户端使用它们时能更加独立
#### 参与者说明:
1. Strategy(策略接口类)
   提供“策略客户端可以使用的方法
2. ConcreteStrategyA-ConcreteStrategyC(策略实现类)
   不同算法的实现
3. Context(策略客户端)
   拥有一个Strategy类的对象引用，并通过对象引用获取想要的运算结果。
#### 优点
1. 让角色属性变得好维护
2. 不必再针对角色类型编写程序代码
3. 计算公式的替换更为方便

### 模板方法模式(Template Method)
在一个操作方法中定义算法的流程，其中某些步骤由子类完成，模板方法模式让子类再不变更原有算法流程的情况下，能够重新定义其中的步骤。
#### 参与者说明:
1. AbstractClass(算法定义类)
   定义算法架构的类
   可以在某个操作方法(TemplateMethod)中定义完整的流程
   定义流程中会调用到方法(PrimitiveOperation)，这些方法将由子类重新实现
2. ConcreteClass(算法步骤的实现类)
   重新实现父类中定义的方法，并可按照子类的执行情况反应步骤实际的内容
#### 优点
需要变化的内容，由实现的子类负责，原本需要再子类中重复实现算法的缺点不会再出现。

### 工厂方法模式(Factory Method)
定义一个可以产生对象的接口，但是让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化程序延迟到子类中实施。
#### 参与者说明:
1. Product(产品类)
   定义产品类的操作接口，而这个接口将有工厂产出
2. ConcreteProduct(产品实现)
   实现产品功能的类，可以不只定义一个产品实现类，这些产品实现类的对象都会由ConcreteCreator(工厂实现类产生)
3. Creator(工厂类)
   定义能产生Product(产品类)的方法:FactoryMethod
4. ConcreteCreator(工厂实现类)
   实现FactoryMethod，并产生指定的ConcreteProduct(产品实现)
#### 优点
将类群组对象的产出流程整合于同一个类实现，并提供唯一的工厂方法，让项目内的“对象产生流程”更加独立。

### 建造者模式(Builder)
将一个复杂对象的构建过程与他的对象表现分离出来，让相同的构建流程可以产生不同的对象行为表现。
#### 参与者说明:
1. Director(建造指示者)
   负责对象构建时的“流程分析安排”
   再Construct方法中，会明确定义对象组装的流程，即调用Builder接口方法的顺序
2. Builder(功能实现接口)
   定义不同的操作方法将“功能分开来实现”
   其中的每个方法都是用来提供给某个复杂对象的一部分功能，或是提供设置规划
3. ConcreteBuilder(功能实现类)
   Builder的具体实现，实现产出功能的类
   不同的ConcreteBuilder(功能实现类)可以产出不同的功能。用来实现不同对象的行为表现和功能。
4. Product(产品)
   代表最终完成的复杂对象，必须提供方法让Builder类可以将各部位功能设置给它。

#### 优点
在重构后的角色工厂中，只简单负责角色的“产生”，而复杂的功能组装工作交由新增加的角色建造系统来完成。将角色功能的组装流程独立出来。

### 享元模式(Flyweight)
享元模式用来解决“大量且重复的对象”的管理问题。
使用共享的方式，让一大群小规模对象能更有效地运行
只能读取不能写入的共享部分成为内在状态，如最大生命力，移动速度等
而不能被共享的部分，如当前生命值等为外在状态
产生对象时，将能够共享的内在状态加以管理，并且将属于各对象能自由更改的外部状态也一起设置给新产生的对象中。
#### 参与者说明:
1. FlyWeightFactory(工厂类)
   负责产生和管理FlyWeight组件
   内部通常使用容器类来存储共享的FlyWeight组件
   提供工厂方法产生对应组件，当产生的时共享组件时，就加入FlyWeight管理容器内
2. FlyWeight(组件接口)
   定义组件的接口操作
3. ConcreteFlyWeight(可以共享的组件)
   实现FlyWeight接口
   产生的组件是可以共享的，并加入到FlyWeight容器中
4. UnSharedConcreteFlyWeight(不可以共享的组件)
   实现FlyWeight接口，也可以选择不继承自FlyWeight接口
   可以定义为单独额组件，不包含任何共享资源
   也可以将一些共享组件定义为类的成员，成为内部状态；并另外定义其他不被共享的成员，作为外部状态使用。
#### 优点
可以将属性设置集以更简短的格式呈现。且共享属性的部分，每一个编号对应的属性对象，在整个游戏执行中指挥产生一份，不像旧方法那样会产出重复的对象而增加内存的负担。
最常被使用到属性系统。

### 组合模式(Composite)
将对象以树状结构组合，用以表现部分-全部的层次关系。组合模式让客户端在操作各个对象或组合对象时是一致的。
#### 参与者说明:
1. Component(组件界面)
   定义树状结构中，每一个节点可以使用的操作方法
2. Composite(组合节点)
   即根节点的概念
   会包含叶结点的对象
   会实现Component(组件界面)中与子节点操作有关，如Add、Remove、GetChild等
3. Leaf(叶子节点)
   不再包含任何子节点的最终节点
   实现Component(组件界面)中基本的行为，对于与子节点操作有关的方法可以不实现，也可提出警告或弹出例外(Exception)
#### 优点

### 命令模式(Command)
将请求封装成对象，让你可以将客户端的不同请求参数化，并配合队列、记录、复原等方法来执行请求的操作。

主要为请求的封装和请求的操作两部分。

当请求被对象化，对于请求对象是否有管理上的需求，如果有，则以命令模式实现。

#### 优点
将请求对象封装为对象后，对于命令的执行，可加上额外的操作和参数化。

### 责任链模式(Chain of Responsibility)
让一群对象都有机会来处理一项请求，以减少请求发送者与接收者之间的耦合度(即依赖度).将所有的接收者对象串接起来，让请求沿着串接传递，直到有一个对象可以处理为止。
#### 优点


### 观察者模式(Observer)
在对象之间定义一个一对多的连接方式，当一个对象变换状态时，其他关联的对象都会自动收到通知。
#### 优点

### 备忘录模式(Memento)
在不违反封装的原则下，获取一个对象的内部状态并保留在外部，让该对象可以在日后恢复到原先保留时的状态
#### 优点

### 访问者模式(Visitor)
定义一个能够在一个对象结构中对于所有元素执行的操作。访问者让你可以定义一个新的操作，而不必更改到被操作元素的类接口。
#### 优点

### 装饰模式(Decorator)
动态地附加额外的责任给一个对象。装饰模式提供了一个灵活的选择，让子类可以用来扩展功能。
#### 优点

### 适配器模式(Adapter)
将一个类的接口转换成为客户端期待的类接口。适配器模式让原本接口不兼容的类能一起合作
#### 优点

### 代理模式
提供一个代理者位置给一个对象，好让代理者可以控制存取这个对象
#### 优点
