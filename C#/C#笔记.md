## 浮点数
### 原理 
相差与浮点数的定点数，它的小数点固定的位于实数所有数字中间的某个位置，比如99.00和00.99可以用于表达具有四位精度。
定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。最终，绝大多数现代的计算机系统采纳了所谓的浮点数表达方式。
浮点数表达，使用科学计数法来表达实数，就是使用一个尾数，一个基数，一个指数以及一个表示正负的符号来表达实数，比如123.45用十进制科学计数法可以表达为1.2345×10e2，其中1.2345为尾数，10为基数，2为指数。这样就可以利用指数达到了浮动小数点的效果。
同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 101，0.12345 × 103 或者 1.2345 × 102。
### 注意点
浮点数在数值比较的时候可能不相等，所以最好使用近等于来比较浮点类型。
### 解决办法
1. 就是只计算一次，并认定这个值为准确值，只用这个变量结果做判断，也省去了多次计算浪费的CPU
2. 可以用int或long类型来替代浮点数
3. 用定点数保持一致性并缩小精度问题，浮点数计算是比较模糊的，所以可以将定点数整数部分和小数部分拆开来计算，因为整数计算是确定的，所以不存在误差。
4. 如果需要精度非常高，可以使用字符串替代浮点数，但是这样CPU和内存消耗非常大。

## IList和List区别
List继承自IList接口.
IList实现有三种类别:只读，固定大小，可变大小。
无法修改只读IList。固定大小的IList不允许添加或移除元素，但允许修改。可变大小都允许。

## C#委托
委托可以理解为持有一个或多个方法的对象。如果执行委托的话，委托会执行它所持有的方法。委托可以避免程序中大量使用if-else语句。是程序拥有跟好的拓展性。

委托和类一样，是一种用户自定义的类型，但类表示的是数据和方法的集合，而委托则持有一个或多个方法，以及一系列预定义的操作。

delegate void MyDel(int x)
delegate 作为委托关键字，没有方法主体。

### event和delegate关系
event很简单，它在委托delegate上，又做了一次封装，这次封装的意义是，限制用户直接操作delegate委托实例中变量的权限。
封装后，用户不再能够直接用赋值(即使用=等号操作符)操作来改变委托变量了，只能通过注册或者注销委托的方法来增减委托函数的数量。也就是说被event声明的委托不再提供‘=’的操作符，但仍然有'+=’和‘-=’的操作符可供操作。
为什么要限制呢?因为在平时的编程中，由于项目太过庞大，经手的人员数量太多，导致我们常常无法得知其他人在编写的代码是什么有什么意图，这样公开的delegate委托会直接暴露在外，随时会被‘=′赋值而清空了前面累积起来的委托链表，委托的操作权限范围太大导致问题会比较严重。申明event后，编译器内部重新封装了委托，让暴露在外面的委托不再担心随时被清空和重置的危险。因为经过event封装后不再提供赋值操作来清空前面的累加，只能一个个注册或者一个个注销委托(或者说函数地址)，这样就保证了谁注册就必须谁负责销毁的目的，更好的维护了delegate的秩序。
