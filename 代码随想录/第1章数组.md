# 数组概述
1. 数组是存放在连续内存空间上的相同类型数据的集合。  
2. 数组可以方便的通过下标索引的方式获取到下标对应的数据。
3. 数组下标都是从0开始的。数组内存空间的地址是连续的正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，
4. 使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。
5. 数组的元素是不能删的，只能覆盖。
6. 那么二维数组在内存的空间地址是连续的么？不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。


## [二分查找](https://leetcode.cn/problems/binary-search/)
非常经典地一道题目，题目为有序数组且没有重复元素,这些都是二分法地前提条件。而其中最重要的就是边界划分，本题使用左闭右闭区间，所以两个边界都一定要有意义，所以right 初始化为nums.size()-1,如果初始化为nums.size()，那么就应该使用左闭右开区间了。  
然后就是既然使用了左闭右闭，所以left==right也有意义,所以有如下两点  
1. while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=  
2. if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 

```cpp    
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0,right = nums.size()-1;
        while(left <= right)
        {
            int middle = left +(right-left)/2;
            if(nums[middle] >target)
            {
                right = middle -1;
            }
            else if(nums[middle] < target)
            {
                left = middle +1;
            }
            else
            {
                return middle;
            }
        }
        return -1;
    }
};
```