# 栈与队列概述
## 栈
栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。

**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。

那么问题来了，STL 中栈是用什么容器实现的？

从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。

## 队列

# 题目

## [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)
### 题目概述
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
### 解答
使用两个栈一个模拟入队，一个模拟出队。
### 代码
```cpp
class MyQueue {
public:
    stack<int> stkIn;
    stack<int> stkOut;
    MyQueue() {

    }
    
    void push(int x) {
        stkIn.push(x);
    }
    
    int pop() {
        if(stkOut.size() == 0)
        {
            while(stkIn.size() != 0)
            {
                stkOut.push(stkIn.top());
                stkIn.pop();
            }
        }
        int result = stkOut.top();
        stkOut.pop();
        return result;
    }
    
    int peek() {
        int result = this->pop();
        stkOut.push(result);
        return result;
    }
    
    bool empty() {
        return stkIn.empty()&&stkOut.empty();
    }
};
```

## [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/description/)
### 题目概述
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
###
使用一个队列就能够实现，入队还是正常操作，在模拟出栈时可以将出队size()-1个元素并将其逐个再入队，则首个元素就是栈顶元素。
### 代码
```cpp
class MyStack {
public:
    queue<int> que;
    MyStack() {

    }
    
    void push(int x) {
        que.push(x);
    }
    
    int pop() {
        int size = que.size();
        size--;
        while(size--)
        {
            que.push(que.front());
            que.pop();
        }
        int result = que.front();
        que.pop();
        return result;
    }
    
    int top() {
        int size = que.size();
        size--;
        while(size--)
        {
            que.push(que.front());
            que.pop();
        }
        int result = que.front();
        que.push(que.front());
        que.pop();
        return result;
    }
    
    bool empty() {
        return que.empty();
    }
};
```

## [有效的括号](https://leetcode.cn/problems/valid-parentheses/)
### 题目概述
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
### 题解
在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了。

### 代码
```cpp    
class Solution {
public:
    bool isValid(string s) {
    if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        return st.empty();
};
```