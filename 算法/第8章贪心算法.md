# 贪心算法概述
贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
所以唯一的难点就是如何通过局部最优，推出整体最优。

那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？

不好意思，也没有！ 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。
面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了。
贪心算法一般分为如下四步：

将问题分解为若干个子问题
找出适合的贪心策略
求解每一个子问题的最优解
将局部最优解堆叠成全局最优解
# 题目
## [分发饼干](https://leetcode.cn/problems/assign-cookies/description/)
### 题解
求最优解，自然是让尺寸大饼干能够尽可能满足胃口大的孩子，那么就可以将两个数组都排序，然后从胃口大的孩子往下遍历，尽可能满足这些孩子。
### 代码
```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int index = s.size() - 1;
        int result = 0;
        for(int i = g.size() - 1; i >= 0; i--){
            if(index >= 0 && s[index] >= g[i]){
                index--;
                result++;
            }
        }
        return result;
    }
};
```

## [摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)
### 题解
求摆动序列长度，主要还是分类讨论：
情况一：上下坡中有平坡
情况二：数组首尾两端
情况三：单调坡中有平坡
实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）

这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点
### 代码
```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        int curDiff = 0;
        int preDiff = 0;
        int result = 1;
        for(int i = 0; i < nums.size()-1; i++){
            curDiff = nums[i+1] - nums[i];
            if((preDiff<=0 && curDiff > 0) || (preDiff>=0 && curDiff <0)){
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
}; 
```

## [最大子序和](https://leetcode.cn/problems/maximum-subarray/description/)
### 题解
局部最优的情况下，并记录最大的“连续和”，可以推出全局最优
从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。
### 代码
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for(int i = 0; i < nums.size(); i++){
            count += nums[i];
            if(count > result){
                result = count;
            }
            if(count <= 0) count = 0;
        }
        return result;
    }
};
```

## [买卖股票的最佳时机Ⅱ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)
### 题解
本题同时只会有一支股票，那么就可以计算两天之间的盈亏，将所有盈利的都加起来。
### 代码
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for(int i = 1; i < prices.size(); i++){
            result += max(prices[i] - prices[i - 1],0);
        }
        return result;
    }
};
```

## [跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
### 题解
贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。
### 代码
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
```

## [跳跃游戏Ⅱ](https://leetcode.cn/problems/jump-game-ii/description/)
### 题解

### 代码
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;
        int ans = 0;
        int nextDistance = 0;
        for(int i = 0; i < nums.size()-1; i++){
            nextDistance = max(nums[i] + i, nextDistance);
            if(i == curDistance){
                curDistance = nextDistance;
                ans++;
            }
        }
        return ans;
    }
};
```

## [K次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)
### 题解
先将数组排序，倒序肯定是优先将负数倒过来，全部倒过来后，在排序一遍，如果k还有剩下的，说明已经是一个递增正数序列了，则看k%2 == 1，如果等于1，那就把最小的，即第一个倒过来，如果不为1，那就不用管，因为乘两次-1等于没乘。
### 代码
```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] < 0 && k > 0){
                nums[i] *= -1;
                k--;
            }
        }
        sort(nums.begin(),nums.end());
        if(k%2 == 1) nums[0] *= -1;
        int result = 0;
        for(int a : nums){
            result += a;
        } 
        return result;
    }
};
```
```cpp
class Solution {
public:
    static bool cmp(int a, int b) {
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end(),cmp);
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] <0 && k > 0){
                nums[i] *= -1;
                k--;
            }
        }
        if(k %2 == 1) nums[nums.size() - 1] *= -1;
        int result = 0;
        for(int a : nums){
            result += a;
        }
        return result;
    }
};
```

## [加油站](https://leetcode.cn/problems/gas-station/description/)
### 题解
首先定义一个curSum表示当前油箱剩余油量，还有一个min就是整个过程中油箱油量最小的时候。
从0开始遍历，遍历完之后，如果curSum < 0,则说明消耗总油量大于获得总油量，则说明一定不够，返回-1，如果最小油量都是>= 0, 则说明这个路线行得通，返回0。如果都不满足，则从后往前遍历，不断计算当前位置的差值并加到min上，知道min>=0了，则返回当前位置i。如果都没找到，则返回-1。
### 代码
```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int min = INT_MAX;
        for(int i = 0; i< gas.size(); i++){
            curSum += (gas[i] - cost[i]);
            if(curSum < min){
                min = curSum;
            }
        }
        if(curSum < 0) return -1;
        if(min >= 0) return 0;
        for(int i=gas.size() - 1; i>= 0; i--){
            min += (gas[i] - cost[i]);
            if(min >= 0){
                return i;
            }
        }
        return -1;
    }
};
```