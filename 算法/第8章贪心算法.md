# 贪心算法概述
贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
所以唯一的难点就是如何通过局部最优，推出整体最优。

那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？

不好意思，也没有！ 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。
面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了。
贪心算法一般分为如下四步：

将问题分解为若干个子问题
找出适合的贪心策略
求解每一个子问题的最优解
将局部最优解堆叠成全局最优解
# 题目
## [分发饼干](https://leetcode.cn/problems/assign-cookies/description/)
### 题解
求最优解，自然是让尺寸大饼干能够尽可能满足胃口大的孩子，那么就可以将两个数组都排序，然后从胃口大的孩子往下遍历，尽可能满足这些孩子。
### 代码
```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int index = s.size() - 1;
        int result = 0;
        for(int i = g.size() - 1; i >= 0; i--){
            if(index >= 0 && s[index] >= g[i]){
                index--;
                result++;
            }
        }
        return result;
    }
};
```

## [摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)
### 题解
求摆动序列长度，主要还是分类讨论：
情况一：上下坡中有平坡
情况二：数组首尾两端
情况三：单调坡中有平坡
实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）

这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点
### 代码
```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();
        int curDiff = 0;
        int preDiff = 0;
        int result = 1;
        for(int i = 0; i < nums.size()-1; i++){
            curDiff = nums[i+1] - nums[i];
            if((preDiff<=0 && curDiff > 0) || (preDiff>=0 && curDiff <0)){
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
}; 
```

## [最大子序和](https://leetcode.cn/problems/maximum-subarray/description/)
### 题解
局部最优的情况下，并记录最大的“连续和”，可以推出全局最优
从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。
### 代码
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for(int i = 0; i < nums.size(); i++){
            count += nums[i];
            if(count > result){
                result = count;
            }
            if(count <= 0) count = 0;
        }
        return result;
    }
};
```

## [买卖股票的最佳时机Ⅱ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)
### 题解
本题同时只会有一支股票，那么就可以计算两天之间的盈亏，将所有盈利的都加起来。
### 代码
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for(int i = 1; i < prices.size(); i++){
            result += max(prices[i] - prices[i - 1],0);
        }
        return result;
    }
};
```

## [跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
### 题解
贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。
### 代码
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
```

## [跳跃游戏Ⅱ](https://leetcode.cn/problems/jump-game-ii/description/)
### 题解

### 代码
```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;
        int ans = 0;
        int nextDistance = 0;
        for(int i = 0; i < nums.size()-1; i++){
            nextDistance = max(nums[i] + i, nextDistance);
            if(i == curDistance){
                curDistance = nextDistance;
                ans++;
            }
        }
        return ans;
    }
};
```