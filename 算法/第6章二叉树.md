# 二叉树概述
## 二叉树种类
满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。

若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉排序树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。
## 二叉树存储方式
**二叉树可以链式存储，也可以顺序存储。**
那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。
用数组来存储二叉树如何遍历的呢？

如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。
## 二叉树的遍历方式
二叉树主要有两种遍历方式：

深度优先遍历：先往深走，遇到叶子节点再往回走。
广度优先遍历：一层一层的去遍历。
那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

1. 深度优先遍历
前序遍历（递归法，迭代法）
中序遍历（递归法，迭代法）
后序遍历（递归法，迭代法）
2. 广度优先遍历
层次遍历（迭代法）

这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式

前序遍历：中左右
中序遍历：左中右
后序遍历：左右中

之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。
## 二叉树的定义
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
# 题目
## 二叉树的递归遍历
### 题解
递归算法，一定要确定递归函数的参数和返回值，确定终止的条件，确定单层递归的逻辑。
### 代码
前序遍历:
```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec){
        if(cur == nullptr)
            return ;
        vec.push_back(cur->val);
        traversal(cur->left,vec);
        traversal(cur->right,vec);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root,result);
        return result;
    }
};
```
其他的几种就是调换一下位置而已。

## 二叉树的迭代遍历
### 题解
栈的思想和递归比较类似，所以使用迭代遍历可以使用栈。
### 代码
前序遍历:
```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if(root == nullptr) 
            return result;
        st.push(root);
        while(!st.empty()){
            TreeNode* cur = st.top();
            st.pop();
            result.push_back(cur->val);
            if(cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }
        return result;
    }
};
```
中序遍历:
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```
后序遍历:
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```

## 二叉树的统一迭代遍历
### 代码
中序遍历
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```
其他的遍历也类似，只需要求改一下顺序就可以了

## 二叉树层序遍历 专题

### 1.[二叉树层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
#### 题解
使用一个队列来遍历二叉树，每次都
#### 代码
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        vector<vector<int>> result;
        while(!que.empty()){
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 2.[二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)
#### 题解
和层序遍历一样的做法，只是在每次遍历到i的最后时才填入容器。
#### 代码
```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> result;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0 ; i <size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i == size - 1)
                    result.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

### 3.[二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)
#### 代码
```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> result;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            double num = 0;
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                num+= node->val;
                if(node->left) que.push(node->left);
                if(node-> right) que.push(node->right);
            }
            result.push_back(num/size);
        }
        return result;
    }
};
```

### 4.[N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
#### 代码
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        vector<vector<int>> result;
        if(root != NULL) que.push(root);
        while(!que.empty()){
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                Node* node = que.front();
                que.pop();
                vec.push_back(node->val);
                for(int i =0;i < node->children.size(); i++){
                    if (node->children[i]) que.push(node->children[i]);
                }
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

### 5.[在每个树行中找出最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)
#### 代码
```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> result;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int max = 0;
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->val > max){
                    max = node->val;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(max);
        }
        return result;
    }
};
```

### 6.[.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
#### 代码
```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root != NULL) que.push(root);
        while(!que.empty()){
            int size = que.size();
            Node* node;
            Node* preNode;
            for(int i=0; i<size;i++){
                if(i == 0){
                    preNode = que.front();
                    que.pop();
                    node = preNode;
                }else{
                    node = que.front();
                    que.pop();
                    preNode->next = node;
                    preNode = preNode->next;
                }
                if(node->left) que.push(node->left);
                if(node->right)que.push(node->right);
            }
            preNode->next=NULL;
        }
        return root;
    }
};
```

### 7.[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
#### 代码
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        int depth = 0;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i <size;i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth ++;
        }
        return depth;
    }
};
```

### 8.[二叉树最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)
#### 代码
```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        int depth=0;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth++;
            for(int i=0;i < size;i++){
                TreeNode* node = que.front();
                que.pop();
                if(!node->left && !node->right)
                    return depth;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

## [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)
### 题解
只是将左右子树调换，然后不停递归下去
### 代码
```cpp
//递归法
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
       if (root == NULL) return root;
        TreeNode* tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        invertTree(root->left);         
        invertTree(root->right);       
        return root;
    }
};
//迭代法
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
       if (root == NULL) return root;
        stack<TreeNode*> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top();
            stk.pop();
            swap(node->left,node->right);
            if(node->left) stk.push(node->left);
            if(node->right) stk.push(node->right);
        }
        return root;
    }
};
```

## [对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)
### 题解
要是用后序遍历，其实像这种需要遍历到下面再返回上层的都可以使用后序遍历
### 代码
```cpp
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        return compare(root->left,root->right);
    }
};
```

## [平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)
### 题解
使用后序遍历，递归求每一棵子树的最小最大深度差。如果深度差大于1，就没意义了，直接返回-1，
### 代码
```cpp
class Solution {
public:
// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);//左
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);//右
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max     (leftHeight, rightHeight);//中
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1? false:true;
    }
};
```

## [二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/)
### 题解
这题要求从根节点到叶子节点的顺序，所以使用前序遍历。前序遍历中左右，每次在左右子节点都为空，即节点为叶子节点时，就说明到了一个路径的最后，所以入栈一个路径，不然继续往下递归，但是还要记住要回溯。
### 代码
```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& path,vector<string>& result){
        path.push_back(cur->val);//中
        if(cur->left == nullptr  && cur->right == nullptr){
            string sPath;
            for(int i = 0; i<path.size()-1;i++){
                sPath+= to_string(path[i]);
                sPath+= "->";
            }
            sPath+=to_string(path[path.size()-1]);
            result.push_back(sPath);
            return;
        }
        if(cur->left){//左
            traversal(cur->left,path,result);
            path.pop_back();
        }
        if(cur->right){//右
            traversal(cur->right,path,result);
            path.pop_back();
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if(root == nullptr) return result;
        traversal(root,path,result);
        return result;
    }
};
```
## [左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/description/)
### 代码
```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        queue<TreeNode*> que;
        int sum = 0;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size;i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left && !node->left->left && !node->left->right){
                    sum += node->left->val;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return sum;
    }
};
```

## [完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)
### 题解
正常层序遍历能够完成，但是也可以一直往下遍历，直到找到一棵满二叉树，然后就直接套公式算节点数，在加上之前便利的节点数。
### 代码
```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0,rightDepth = 0;
        while(left){
            left = left->left;
            leftDepth++;
        }
        while(right){
            right = right->right;
            rightDepth++;
        }
        if(leftDepth == rightDepth){
            return (2<< leftDepth)-1;
        }
        return countNodes(root->left) + countNodes(root->right)+1;
    }
};
```

## [找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)
### 代码
```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        int result = 0;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                if(i ==0) result = node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

## [路径总和](https://leetcode.cn/problems/path-sum/description/)
### 题解

### 代码
```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && root->val==targetSum){
            return true;
        }
        return hasPathSum(root->left,targetSum- root->val)|| hasPathSum(root->right,targetSum-root->val);
    }
};
```

## [从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)