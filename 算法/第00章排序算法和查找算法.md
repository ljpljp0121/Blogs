## 冒泡排序
### 算法步骤
比较相邻的元素。如果第一个比第二个大，就交换他们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
### 代码实现
```cpp
void bubble_sort(T arr[], int len){
    int i,j;
    for(i = 0; i < len - 1; i++){
        for(j = 0; j < len - 1 - i; j++){
            if(arr[j] > arr[j+1]){
                swap(arr[j],arr[j+1]);
            }
        }
    }
}
```
```cs
static void BubbleSort(int[] intArray){
    int temp = 0;
    bool swapped;
    for(int i = 0; i < intArray.Length; i++){
        swapped = false;
        for(int j = 0; j < intArray.Length - 1 - i; j++){
            if(intArray[j] > intArray[j+1]){
                temp = intArray[j];
                intArray[j] = intArray[j+1];
                intArray[j+1] = temp;
                if(!swapped)
                    swapped = true;
            }
            if(!swapped)
                return;
        }
    }
}
```

## 选择排序
### 算法步骤
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。
### 代码实现
```cpp
void selection_sort(vector<T>& arr){
    for(int i = 0; i < arr.size()-1; i++){
        int min = i;
        for(int j = i+1; j < arr.size(); j++){
            if(arr[j] < arr[min]){
                min = j;
            }
        }
        swap(arr[i],arr[min]);
    }
}
```
```cs
static void selection_sort<T>(T[] arr){
    int i,j,min,len = arr.Length;
    T temp;
    for(i = 0; i < len-1; i++){
        min = i;
        for(j = i + 1; j < len; j++){
            if(arr[min].CompareTo(arr[j]) > 0){
                min = j;
            }
        }
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}
```

## 插入排序
### 算法步骤
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
### 代码实现
```cpp
void insertion_sort(int arr[], int len){
    for(int i = 1; i < len; i++){
        int key = arr[i];
        int j = i -1;
        while((j >= 0) && (key < arr[j]>)){
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = key;
    }
}
```
```cs
public static void InsertSort(int[] array){
    for(int i = 1; i < array.Length; i++){
        int temp = array[i];
        for(int j = i-1; j >= 0; j--){
            if(array[j] > temp){
                array[j+1] = array[j];
                array[j] = temp;
            }
            else{
                break;
            }
        }
    }
}
```

## 希尔排序
### 算法步骤

### 代码实现