## 1.[反转单链表](https://leetcode.cn/problems/reverse-linked-list/)
### 题目概述
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
### 题解
首先交换两个节点需要明确互相赋值的顺序，然后往后遍历。
### 代码
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* tmp;
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while(cur != nullptr)
        {
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

## 2.[轮转数组](https://leetcode.cn/problems/rotate-array/description/)
### 题目概述
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
### 题解
轮转数组，与右移字符串差不多意思，本质上就是将数组分割成两份，首先整体数组倒转，然后再将分好组的数组逐组倒转，如果轮转的位置k超过了数组大小，则取余，因为轮转一个数组长度其实就是刚好回到原位。 
### 代码
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};
```

## 3.[两数之和](https://leetcode.cn/problems/two-sum/description/)
### 题目概述
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。
### 题解
使用一个哈希表存储遍历过的数值，键为nums[i]，值为i下标。之后每次都遍历一个哈希表中是否有键为target-nums[i]的对，如果有，就说明有答案，直接返回他们俩的下标。
### 代码
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> map;
        for(int i = 0; i < nums.size(); i++)
        {
            if(map.find(target-nums[i]) != map.end())
            {
                return vector<int>{map[target-nums[i]],i};
            }
            map[nums[i]] = i;
        }
        return vector<int>{0};
    }
};
```

## 4.[有效的括号](https://leetcode.cn/problems/valid-parentheses/)
### 题目概述
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
### 题解
在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了。

### 代码
```cpp    
class Solution {
public:
    bool isValid(string s) {
    if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        return st.empty();
};
```

## 5.[每日温度](https://leetcode.cn/problems/daily-temperatures/description/)
### 题目概述
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
### 题解
使用单调栈，这个单调栈始终是温度从大到小排列，且单调栈中存放的是这些温度在数组中的下标(方便计算),而在这个单调栈中主要就是用入栈和出栈来维护，入栈没有什么，主要在于这个出栈。每次遍历到一个新的下标时，都会去比较这个下标温度和栈顶下标温度，如果栈顶下标温度更小，那就需要拿出来，因为单调栈要始终从大到小嘛。而这时出栈的这些下标都是代表着第一次碰到了比他们高的温度。所以此时要将ans数组中对应下标的数值设置为(i-pre)，刚好和我们之前只入栈出栈下标对应，
### 代码
```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> s;
        for(int i = 0; i < n; i++){
            while(!s.empty() && temperatures[i] > temperatures[s.top()]){
                int pre = s.top();
                ans[pre] = i - pre;
                s.pop();
            }
            s.push(i);
        }
        return ans;
    }
};
```